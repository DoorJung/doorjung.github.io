---
title:  "문제: 게임판 덮기"
search: true
categories: 
  - algorithm
last_modified_at: 2019-06-19T10:00:00-12:00:00
---
게임판 덮기
===

문제
---
알고리즘 문제해결전략 6.5~6.6장의 게임판 덮기 문제입니다.  
[문제](https://algospot.com/judge/problem/read/BOARDCOVER)  
문제에 대한 자세한 설명은 위 링크에 있습니다.  

문제접근
---
완전탐색 레시피를 적용시켜 문제를 접근해봅시다!

### 1. 시간안에 풀 수 있을까?
모든 답을 생성해 가며 답의 수를 세는 **재귀 호출 알고리즘은 답의 수에 정비례하는 시간이 걸린다**.

고로 **가장 많은 답을 가지는 경우**를 생각해보자!  
입력에 주어지는 게임판에 있는 흰 칸의 수는 50 을 넘지 않는다고 했으니  
50칸 안에 들어가는 3칸짜리 L자 모양의 블럭의 최대 갯수는 16개  
각 블럭을 놓는 방법의 수는 총 4가지 이므로 16개의 블록을 놓는 방법은 4^16=4294967296...

책을 봐야겠다!
책에서는 **선택할 수 있는 블록 배치가 크게 제한되기 때문에 실제 답의 수는 상한보다 훨씬 작다**고 나와있다.
확실히 공간제약과 중복제거를 고려해 봤을때 가능한 수는 훨씬 적게 나오고  
흰칸이 48개 있는 문제의 마지막 예제에서도 답이 1514개 밖에 되지 않는 점들로 미루어보아 시간안에 답을 구할 수 있다는 생각을 얼추 가질순 있었다.

그래도 찜찜한건 어쩔 수 없지만 일단 문제를 풀어보자!


### 2. 답을 만드는 과정을 여러 개의 조각으로 나누자
블록의 크기는 3이므로 흰 칸의 수를 3으로 나누어 내려놓을 블록의 수 N을 얻은 뒤, 문제의 답을 생성하는 과정을 **N**조각으로 나눠 **한 조각마다 한 블록을 내려놓도록 하자**.

주어진 게임판에 블록을 한개 내려놓고 남은 흰 칸들을 재귀 호출을 이용해 덮으면 문제를 풀 수 있겠다.


###  3. 답의 일부를 만들고, 나머지 답을 재귀호출을 통해 완성
빈칸의 유무를 판단할 변수, 각 단계마다 예외(칸 넘어감, 겹침, 빈칸이 아님)를 처리할 함수가 필요할 것이다.  
중복의 제거를 위해 순서 강제 기법을 사용해 재귀 호출의 각 단계마다 왼쪽 위에 있는 칸을 처음 채운다고 가정하자

코드를 짠다면 대략
```c++
int cover() {
    비어있는 칸 중 제일 왼쪽 위에 있는 칸을 찾는다
    기저 사례 체크
    반복문(블럭이 놓을 수 있는 형태를 다 돌림) {
        if(예외가 아니라면) {
            블럭을 놓음
            재귀
            블록을 치움
        }
    }
}
```
이런 형태가 될것이다.


### 4. 기저 사례
**모든 칸을 채웠을때**이다.

문제 풀이
---
```c++
{% raw %}
#include<iostream>
#include<vector>
using namespace std;

//주어진 칸을 덮을 수 있는 네 가지 방법
//블록을 구성하는 세 칸의 상대적 위치(dy, dx)의 목록
const int coverType[4][3][2] = {
	{ {0, 0}, {1, 0}, {0, 1} },
	{ {0, 0}, {0, 1}, {1, 1} },
	{ {0, 0}, {1, 0}, {1, 1} },
	{ {0, 0}, {1, 0}, {1, -1} }
};
//board의 (x, y)를 type번 방법으로 덮거나, 덮었던 블록을 없앤다.
//delta = 1이면 덮고, -1 이면 덮었던 블록을 없앤다.
//만약 블록이 제대로 덮이지 않은 경우(게임판 밖으로 나가거나,
//겹치거나, 검은 칸을 덮을 때) false를 반환한다.
bool set(vector<vector<int>>& board, int y, int x, int type, int delta) {
	bool ok = true;

	for (int i = 0; i < 3; ++i) {
		const int ny = y + coverType[type][i][0];
		const int nx = x + coverType[type][i][1];
		if (ny < 0 || ny >= board.size() || nx < 0 || nx >= board[0].size())
			ok = false;
		else if ((board[ny][nx] += delta) > 1)
			ok = false;
	}
	return ok;
}
//board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다.
//board[i][j] = 1 이미 덮인 칸 혹은 검은 칸
//board[i][j] = 0 아직 덮이지 않은 칸
int cover(vector<vector<int>>& board) {
	//아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다.
	int y = -1, x = -1;

	for (int i = 0; i < board.size(); ++i) {
		for (int j = 0; j < board[i].size(); ++j) {
			if (board[i][j] == 0) {
				y = i;
				x = j;
				break;
			}
		}
		if (y != -1) break;
	}
	//기저 사레: 모든 칸을 채웠으면 1을 반환한다.
	if (y == -1) return 1;
	int ret = 0;
	for (int type = 0; type < 4; ++type) {
		//만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다.
		if (set(board, y, x, type, 1))
			ret += cover(board);
		//덮었던 블록을 치운다.
		set(board, y, x, type, -1);
	}
	return ret;
}

int main() {
	int c, h, w;

	cin >> c;

	while (c--) {

		cin >> h >> w;

		vector<vector<int>> board(h, vector<int>(w, 0));

		for (int i = 0; i < h; ++i) {
			char input[20];

			cin >> input;

			for (int j = 0; j < w; ++j) {
				//board[i][j] = 1 덮인 칸, board[i][j] = 0 덮이지 않은 칸
				board[i][j] = (input[j] == '#') ? 1 : 0;
			}
		}
		cout << cover(board) << endl;
	}
	return 0;
}
{% endraw %}
```

회고
---
1. 어렵다! 이것이 정녕 난이도 하란 말인가..  
2. 책에서는 덮은과정과 예외처리를 set함수에서 처리했다. 이렇게 한다면 어떤 장점이 있는지 아직은 모르겠으니 내가 처음에 생각했던 방식대로도 한번 풀어봐야겠다.  
3. 중복같은 예외를 처리하는 과정이 생각이 잘 안났다. 항상 예외를 생각해주는 과정을 거치고 문제를 풀어야겠다.



------------
*위 내용의 모든 저작권은 **프로그래밍 대회에서 배우는 알고리즘 문제해결전략**의 저자 구종만님께 있습니다.